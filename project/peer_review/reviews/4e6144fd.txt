Reviewer 1:
9
- The code is well-structured and easy to follow, even for someone who has not been a part of the 
  project and is just looking in from the outside!
- You have used constants for command-line arguments, which helps with the readability, super nice!
- Comments are nice to have, but here there are maybe too many comments that explain something 
  selfexplanitory - eg:
  // Global instance of SharedState
  var GlobalState *SharedState
  Also, try to keep comments to one language. Writing comments in mixed language can make things 
  more confusing
- The is_testing flag is a good way to separate testing logic from the rest of the code, but consider 
  using the flag package in go! Would work great here i think
- The use of os.Args to parse command-line arguments is good
- The id variable is initialized as an empty string and later checked for emptiness. Consider 
  adding a default value or a more descriptive error message if id is empty 
- The id variable is assigned using os.Args[i+1] without checking if i+1 is within bounds. This 
  could lead to an out-of-bounds error if the --id argument is the last argument or if it is not 
  followed by a value. Small edge case/user error situation but nice to take a look at
- Theres a lot of "skeleton" here, but much of the muscle is still missing. This is perfectly 
  fine at this stage, but consider adding more informative comments or fill in the markdown files
  a little more - Maybe its in git issues that i cannot see, in that case this is perfectly fine!
Notes: 
"fmt.Printf("Unknown Arg: %s", arg)" in main.go is missing a newline command. Could be unintended
Theres also no way of turning of the testing flag, as far as i can tell. Im assuming one would just 
restart everything, but maybe add a --no-test flag argument? Not super nessecary.
I would personally refactor the main function to separate argument parsing and testing logic into 
different functions or modules.
There is also a lack of error handling at this point, but i think this part would be in the files 
that have not yet been implemented. Make sure not to forget this, as it is suepr important!!
Other than this, i think this project is looking really good, and im confident you will reach your goal 
if you keep doing exactly what youve been doing!

Reviewer 2:
8
• Main does not contain anything that "starts" the system. Presumably because it is used for testing modules now. Therefore hard to grasp which threads are intialized or dependencies.
• In constants, do not use "ARGV" as this is an abreviation for argument vector.
• From my understanding the project is based on a shared state peer-to-peer network where all nodes synchronize knowing (presumably) everything about each other. This seems reasonable.
• Their plan is to kill and takeover if 3 heartbeats are missed. If the kill-takeover procedure is comprehensive this number should be higher. 3 heartbeats is generally too low for FAT packet loss. 
• Difficult to understand the dependency part as it is little explanation in comments.
• Generally seems like a lot of important and necessary modules are structured well and implemented rigorously.

Reviewer 3:
8
*Comments: The additional descriptions were clear and informative, making it easy to get an overview of each module
*Naming: The function-, struct and variable names were chosen in a way that made their purpose easy to understand.
*Completeness: Each module handles only one specific subject, and the distinction between the different modules was clear. 
*It was easy to navigate between the modules to understand how they designed different parts of the system. 
*They seem to have a solid strategy for testing different functions. This made the code clean and readable, even though the functions were not finished. 
*Some of the function names were written with an underscore, but others were not. This was particularly noticeable in the elevator map, where the naming conventions differed from the other maps. 
*Overall, the system was well-structured and easy to understand. From an external perspective, it seems like they have a solid plan and good control over the further development of the system.

Reviewer 4:
7
Your project has unnecessary files for code-review, making the review process cumbersome. First impression is that your implementation is overcomplicated and your code is bloated.
It is not clear from your top-level code/documentation what your architecture is. As such, it's difficult to read your code,. After reading through your code, it appears that your architecture is purely peer-to-peer, but we are not sure
It is unnecessary to have a go.mod file per package, and this could cause issues. Ideally the structure includes only one go.mod in the root folder, which encompasses the entire project. This file is usually quite simple.
It's great that you have a library for all the constants, this allows for easy access and an overview of all relevant constants. However, is it necessary to separate the elevator constants from the other constants?
In shared_state.go, why does this module control the elevator lights? This seems outside the module's scope.
Your system hierarchy is unconventional; why is your network module under shared state? Why is local_heartbeat a high-level module? From a top-level perspective your system consists of the modules: constants, elevator, local_heartbeat, shared_state and tests. This structure does not relay your design or how the system is interconnected.
It was, in general, difficult to understand the module dependencies in your code. Your project had a difficult entry point for outsiders, although you probably understand your own code. We think you can improve the code if you revisit your structure and modularize more.

