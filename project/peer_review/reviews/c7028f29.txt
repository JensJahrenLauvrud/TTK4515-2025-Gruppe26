Reviewer 1:
9
*Your main function makes it clear what modules are included and how these are connected. I think you use channels well, and the main file shows how the modules depend on each other. 
*lib.rs makes your module hierarchy clear and easy to understand.
*It was easy for me to understand what different variables did based on their names. 
*Your distributor module is currently very chunky and quite complex, with a bunch of stuff going on. It's not entirely easy following the flow of the module, and it is a bit odd that it handles the lights (line 107). You also seem to initialize all_orders twice (as well as some channels). 
*Your receiver module has some odd naming choices (cbc::Sender e.g.) in a module which primary concern is receiving data.  
*The FSM is quite extensive but not hard to follow. I can easily follow what the module takes in and what comes out of it. 
*It is easy to find the implementation of functionality essesntial to the project. For example, your AllOrders struct makes it easy to keep track of orders and their states. It is neat that you keep a table of all offline orders, and that you have implemented a reset offline orders function. Though your distributor is quite chunky, its nice to see that it contributes to backing up orders by distributing these when an elevator comes back online. 
*Final comment: your project seems really solid, but the distributor module is really bulky and heavy to digest in its current form.

Reviewer 2:
8
The project is well-structured and divided into logical modules, making the code modular and easier to maintain and debug. Communication between modules is well-established through message-passing with crossbeam channels. The topology is between a Master-Slave and a Peer-to-Peer system. While all elevators broadcast their "worldview" to each other like in a peer-to-peer network, decisions are made by a designated master. This hierarchy is well understood from the code. The project is well-documented, though the README file is not entirely up to date.
- main.rs:
Provides a clear and well-structured entry point. Configuration is handled using a config file where constants are declared. The ports and elevator ID are read from the command line using a self-defined function. The clap crate could be used as an alternative command-line argument parser.
- elevator_fsm.rs:
Implements a state machine for controlling the elevator. The code is compact but has deeply nested structures (cbc:select, match state, and if statements), making it somewhat difficult to review and debug. Adding comments explaining the logic of if conditions for different order cases could help.
- distributor.rs:
Embeds the receiver.rs and transmitter.rs files for broadcasting UDP messages between nodes. The distributor function also provides functionality to change the master in case of an error. This function is quite large and could be divided into more functions—especially the master redundancy, which could be its own function or module.
- Other smaller modules are well-structured and clear to understand.
Overall, the project is well-advanced and maintains solid code quality.

Reviewer 3:
7
-You should make abstractions of the elevator by using hashmaps and structs and implementing their functions. It’s generally not a good idea to use elevio which is a low-level implementation with such a high level one as ‘distributor’.
-Everything that is now implemented in main can be put in its own file under ‘network’ for example. There is no need to create the threads in main, main can just be used to call the function.
-The loop in distributor should not contain so many if-else statements and should be replaced by a match.
-Generally, redistribute everything distributor does. It is a long function because everything essentially goes through it, that’s why you should extract as much as you can, which also will make your code much more readable. 
-Names of the functions are good name decisions and makes it easier to at least know what you want the function to do but also makes the project as a whole easier to understand.
-You should generally make more structs than initializing long variables. That includes especially every msg-variable you have in the distributor, which will make the code more readable, adjustable and not so easily prone to changes at the low-level. 
-Also the elevator controller with elevator_fsm has a match, but does not match with anything. Now the code works like a normal if-statement, taking the first if-statement first and so on. 

Reviewer 4:
7
* An image file is describing the inner work and relations between every component. This is great and helps a lot to understand the inner architecture. Also it is very clear the project is master/backup oriented.
* Naming is perfect, everything seems to be at the right place. Constants are stored in separate files making configuration easier later on.
* The fsm could be enhanced by having raw conditions replaced by named functions to better comprehend the logic behind it. Comments are welcomed as well (Do one or the other, since 1) is self explanatory and 2) would make 1) redundant). 
*Also split your code in functions, it is not clear at first glance of all the responsibilities of the FSM since it's all packed in a single, almost 300 lines function. Some comments are not in English.
* In a lot of places, the state is mutated with complex conditions that are mostly undocumented. While some reading and common sense make up for it, The code would be way better with just some comments along the way.
* The general idea of using select for almost everything is great, It allows less of the multithreading headache.
* Event handling is easy to follow as it is done in the same way for every part of the code.
* The project is in an advanced state. With the FSM completed and the network part on the way. This is promising, keep it up.
* UDP is implemented, but not TCP. How are the packet losses handled? Maybe look into some of the benefits of using TCP as well for its acknowledgement protocols.
* In cost_function.rs, the assign_orders takes in both cab and hall order. This seems unnecessary, since each cab is responsible for taking its own orders.
* A crate called “controller” is included, but it’s called “distributor” in another place. A mistake?
* The return types or descriptive names of several recv() functions have not been specified in transmitter.rs, making it hard to get a good overview or understanding of the code. Instead of recv(new_state_rx) -> a, you can for example write: recv(new_state_rx) -> new_state_result.

Reviewer 5:
8
Top level entry points: The initial look at the structure of the folders and the naming of the files gives an orderly feel. When looking closer at main.rs it seems that this entry point is mainly just to spawn the elevators and implement an unending loop so the rest of the threads can run, which is a nice way to do it, even though the code should include a few more comments so it is more understandable.
The master slave functionality is apparent, but the behaviour of each elevator is very spread and getting a complete understanding of the system is difficult.
Individual modules from the outside:
Each module seems to be working with only one subject, this makes the code structured, except some of the distributor modules, which we believe could be simplified, or separated into smaller pieces (ex. Making a separate function  for interpreting messages from the receiver, preparing messages and a function for sending the messages). 
Individual modules from the inside:
The code could not be described as entirely self documenting, since it is not completely obvious what each and every function does. 
But there is a lot of functionality which is easy to understand as well. Everything inside the elevator controller is structured and understandable, the cost function module and main is also easy to understand. 
The states of the elevator seems to be modified in several separate places, we believe this could cause problems if the threads try to modify it at the same time.
Interactions between modules:
The modules seem to be interacting well, the only comment is that it might need a bit more separation. 
There is also a slight lack of tracability which might be fixed by moving some of the distributor functionality to main, we believe this could make the entire systems functionality more apparent. 
Details:
The variable naming is good, but we believe that you can make the code more understandable by adding more comments, and making some of the variable names more distinct. 
Gut feel: It seems like there is a good idea behind the system and I believe that it will work well when it is finished. I believe that the system could be split into a bit more functions that do less, with names that make the functionality more blatant. There is also a severe lack of comments that in combination with the big functions (that do a lot of things), makes it a bit hard to understand. As a whole the behaviour seems good, and we believe that the only place where the code is lacking is traceability and naming.  Gut feeling 8/10 it is good!


