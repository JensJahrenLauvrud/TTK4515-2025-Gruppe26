Reviewer 1:
7
- Clean and tidy file system on folder level. Easy to understand what to expect in the different folders.
- Based on the orders file it seems like you have complicated things up a bit. As an example, I do not get why you need one separate function for Remove_order, one for Handle_removed_orders and then another one for Remove_non_cab_orders. There might be a good reason for why you have done this partition, but it is not communicated clear to me.
- It seems like orders.go and queue.go have some similar functionality and therefore could be merged together as one moldule. 
- Your statemachine file is relatively clean and maintainable, good.
- In genereal, in your elevator folder the partition of the different files seems a bit random ( except from the statemachine file). Maybe try to fix this in order to handle unexpected errors.
- Your datatypes-file is clean. Good use of comments here. Would be great with more of that.
- The overall structure is quite easy to get. You have a master-slave structure and in general most of the functions in the whole master folder is reasonable and relatively easy to understand. 

Reviewer 2:
9
•Structure: The system is divided into a master and slave. There are two main functions in the main package which is generally not advisable. Instead it would be better to pass the role through the command line when running the code.
•Fault tolerance: the systems seems to use a process pair technique for handling a master failing. It seems to be implemented in a good way, promoting a backup if it fails. It seems to backup cab orders in a good way. It handles state sync through a confirmation process, which is good.
•Code quality: It seems to have a readable structure and with reasonable modularization. Maybe consider removing the handler functions from elevator.go and master.go. They seem to be used a single time, in golang the most idiomatic approach is to avoid this because the case statement already modularizes the code for you. Watch Anders code quality lecture to see what we mean. Naming conventions: in go it is a better practice to avoid duplicate function names after package names. Instead of master.Run_master_backup() it would be more idiomatic to name it master.Run_backup()
•Final thoughts: the code seems to be well thought, with some fault tolerant mechanisms which is a big part of this project. The code quality is also reasonably good, given this time in the project phase. Keep up the good work.

Reviewer 3:
7
 - Make sure to keep the naming convention consistent. Idiomatic go uses camelCase and PascalCase for public and private variables.
 - Problem: Threads which are running as methods on structs have the ability to mutate any value in the struct, meaning that the struct is a shared variable between all these threads (for instance Elevator.Connect_elevator and Elevator.State_machine), but the struct has no thread safety mesaure. Consider refactoring this using message passsing so you don't have multiple threads mutating / reading from the same struct (tip: use go run -race [filename.go] ro run a race condition detector, which is built into the go programming language). Also check out https://www.youtube.com/watch?v=6nIhDFF1D5U 
 - Another related problem here is that the Elevator struct which these functions are members of is a bit big, so it might be a good idea to divide this. At least change something about which goroutines do what, because now every goroutine which is a member function of Elevator can mutate any member variables. It's also not great that Elevator manages both connections and elevator states, these can be divided into two structs
 - Regarding TCP connections: Note that TCP connections have a quite large problem: TCP connections *will* stop working under artificially high packet loss due to congestion control algorithms, which cannot be changed on the user side (https://en.wikipedia.org/wiki/TCP_congestion_control). This means that every connection will most likely fail under high packet loss (maybe even during moderate packet loss, have you tested this?) Note that the packet loss simulator doesn't really work, so you can use something like this (https://stackoverflow.com/questions/614795/simulate-delayed-and-dropped-packets-on-linux) netem package to get more accurately simulated packet loss
 - Regarding for instance the elevator module: We don't need every function and member to be public, since we only call Run_single_elevator() from the outside. Try to start with everything private, and then make things public when necessary. This means that every exposed member or function actually needs to be exposed.
 - Note that you can make local packages without needing to declare go modules for each of them, just make a folder with go files in and it automatically becomes a package with protection of exposed variables like you would expect.
 - It may be a good idea to split up the elevator and master modules a little, as these are very big and have a lot of complex functionality which could be simpler if we limit how they can interact by creating submodules inside elevator and master. For instance it's natural to make queue its own module, and then exposing functionality via public functions (right now Queue.Orders is public!! (not good))
 - The functions themselves are very well written and easy to follow. It is also cler that you have made good decisions about which pieces of funcionality to turn into functions (i.e. functions only do one thing, and than thing is clearly defined and easy to understand). The one exception to this is probably the usage of HandleXX-functions, it might be a good idea to try to limit the usage of these as they make it somewhat unclear what the function really does.
 - Most comments are unnecessary and can be removed. If the code is still unclear, rename some variables, for example in the bck_msgChan case on line 125 in master.go you could remove the comment and rename bck_msgChan to something like masterMessages or masterMessageChan. Maybe consider writing a top-level comment above your main function which describes the overall functionality of the threads and channels
 - Gut feeling: 7. The code overall doesn't have major flaws, the entry point is an interface between modules (which is good), the flow of information is easy to follow, but the codebase quite big and it seems difficult to track down bugs in such an interconnected system, also there are quite a few shared variables which can make the program hard to test and cause race conditions.

Reviewer 4:
8
- Overall Structure: The folder and package organization is very clear: each major concern (elevator logic, networking, master backup) sits in its own package. This separation helps keep the codebase navigable.
- Entry Points: Having two clear entry files (run_master.go and run_elevator.go) makes it straightforward to start either the master or an elevator. The README instructions match these files nicely.
- Concurrency with Channels: The system has multiple goroutines and timers; switching to a channel-based approach for queue updates and elevator/master events would prevent data races and simplify concurrency. For example, a “queue manager” goroutine could receive button presses via channels rather than handling them in multiple goroutines.
- Modular Designs: The code sticks well to single-responsibility per package (master handles distribution and backup; elevator handles local logic), which is a strong architecture choice.
- Queue Handling: Splitting “master queue” (distributed orders) from “elevator queue” (local orders) makes sense. Just be mindful of subtle duplication in re-sending or redistributing orders (e.g., Resend_queue vs. Resend_finished_orders).
- Naming & Readability: Most function and variable names are descriptive and relativly concise, but some are inconsistent (e.g., Handle_floor_signal vs. Add_order). Standardizing to typical Go naming (no underscores, consistent function styles) would make the code look more idiomatic.
- Comments: Several of the comments felt unnecessary as the code was easy to read e.g. the comments in the function Handle_new_messages(). Could however be good to add comment to color-module to explain its purpose.

