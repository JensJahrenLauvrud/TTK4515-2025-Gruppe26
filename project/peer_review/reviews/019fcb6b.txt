Reviewer 1:
7
bullet point 1: Consider using an enum with associated information for pub const variables in prelude.rs (lines 88–90 and 100–107).
bullet point 2: Consider implementing fmt::Display for outputting structs and enums instead of using specific print() functions. This also applies to debug functions.
bullet point 3: Consider initializing Status::target_floor to None instead of Some(u8::MAX). It makes little sense to initialize an order with specific order information (e.g., target_floor). The same applies to initializing the Order struct.
bullet point 4: Consider using a configuration file—or an alternative method—for loading initial constants, IP addresses, etc. This would make it easier to adjust project parameters.
bullet point 5: In elevator.rs, the functions elevdirn_to_halldirn(), halldirn_to_elevdirn(), opposite_direction_hall, and check_for_stop() are unnecessary and are used only once throughout your project. These functions could be written directly in place to avoid unnecessary overhead from cloning and borrowing data. The same applies to other similar functions in your project.
bullet point 6: Please remove unused code. There are many lines that are not used in your design.
bullet point 7: In elevator.rs, the open_door function sleeps for 3 seconds, blocking all other incoming and outgoing commands. This issue could be resolved by spawning a separate thread for the door timer.
bullet point 8: Consider toggling the lights on and off within the same function (see elevator.rs: check_lights()).
bullet point 9: Consider renaming the function check_for_bottom() to better reflect its actual purpose—for example, check_for_end_floors(). The same applies to order_up() on line 24 in master.rs.
bullet point 10: In the function elevator_controller() on line 305, what is the rationale for hard-setting floor_number to 0? Please comment on this or consider implementing it differently.
bullet point 11: Ensure consistency with data types. In master.rs, cost_of_order() casts from u8 to i32 and then back to u8. Please keep your data types consistent.
bullet point 12: Tips for the Future: Check and resolve warnings. The Rust compiler provides excellent feedback on everything from unused code to naming conventions. We understand that this is not the final project, but we miss the networking and error handling. What happens when an elevator fails? What happens when the master fails? Please update your README to explain the program flow of your project. Overall, this is a good starting point for further development.

Reviewer 2:
9
- Some magic numbers in prelude.rs (u8::MAX) which are not defined/explained. Could also save a few lines of code by tweaking the way libraries are imported; use crossbeam\_channel::\{self as cbc, select, Sender, Receiver};, use driver_rust::elevio::elev:: *;
- the Master-thread should have a backup in case of program failure. Could be done by implementing a watchdog-timer which continuously checks for hang-ups in the system, and then quits the master-thread and spawns a backup.
- Might have overlooked, but couldn't see any prioritization between the "slaves". This could be useful if the group wants to efficiently distribute the orders. They could for example use a cost function to determine which elevator is more "willing" and assign the order to the said elevator, or predetermine a priority list of the elevators.
- overall coherent code with explanatory comments where it is necessary. The addition of the README was great, and it was not difficult to navigate the code.
-  the run-master function in masters.rs is quite large, and could maybe be divided into two separate functions; a function which handles communication and a function which spawns the processes.
- run-elevator function is also a little long, and could be divided into several smaller functions; message-handling and state updates.
- In the order_up function in masters.rs, the cost calculation seemingly gets accumulated over time. A way to mitigate this could be to clear it at the end.

Reviewer 3:
7
-Consider splitting into multiple modules, e.g the current elevator file should be split. Other modules should probably be split as the project evolves.
-If splitting the files, consider renaming the prelude file and include all other files in a folder with the same name, then you won't have to use pub for every element in prelude 
 and can import the desired components using use super::{comp1,comp2...} They will be available even though the component is not pub. This is better explained here: https://doc.rust-lang.org/rust-by-example/mod/split.html 
-In general, try to avoid datatype conversion if not necessary, it is adding extra complexity. It has been done in master::cost_of_order where you are converting u8 to i32, 
 doing arithmetic, and then converts back to u8. We see the issue when using the difference in abs, but this can be solved using min and max instead to find the difference.
-The word master is used for one module, but in your planned three, you have one master and multiple slaves. Have you thought about which parts of the master and slaves that should be equal/differ? 
 Your current master is both sending out orders, which should be done by a proper master. But it is also taking in an elevator argument to use call_buttons , using that will only affect its connected elevator. 
 (call_buttons are now used in both elevator and master. )
-At multiple occasions you are writing on a channel before awaiting the reply. This could fail due to race conditions. If this happens in multiple threads at the same time, the waiting thread could receive the wrong reply. 
 If you only had done this with threads that you do not clone, it could be okay, but that means an extra thing to pay attention to.
-Try using something other than unwraps as fault check as it panics on error, considering match or expect with error message. 
-Defining the call_button channels in both master and elevator might lead to only one of either master or elevator getting the call. (Call_button only sends one for each new call) This could lead to missed calls.

Reviewer 4:
8
- Global variables in prelude could be restructured as enum.
- Too many single line comments like start of main function in main.rs. Does every single line need a comment? Maybe change some names instead?
- Hard to understand Project structure from file names; you have master-slave picture but the names are master and elevator? Similarly, the names main and master made it hard to induce the entry point of the program.
- Difficult to learn the functionality by reading the code but this is also the fault of Rust...
- The functionality of especially the elevator could be contained in a struct/impl structure.

Reviewer 5:
7
- We would suggest splitting the prelude module, the name semantically does not describe anything about what the module actually contains. Having separate Status, Networking and Order modules might be clearer.
- We suggest adding general documentation to methods and types. Some are documented but you should use standard syntax for doc-strings startings in rust. This way your IDE and other tooling will pick up on your documentation, and it will be easier for others to use as it is written in the standard way.
- The intention attribute in InternalCommunication is both hard to understand and leaves the code vulnerable to errors. Consider using a narrower type like an enum instead of a u8. This will also clean up the code as it was not clear at all what the constants DELETE, INSERT, … , were used for. Wrapping all values in an enum Intention would organize it better. The same goes for comm_type and the direction of elevator movement.
- On a related note: the one above your pattern match in direction_to_string and elevdirn_to_halldirn have hard to read default cases. Consider using a standard default case instead of the interval. The way your code is now also has a problem with maintainability as if you decide to change the value of for example DIRN_UP you must also update your “default”/”error”-case in the match.
- Consider giving your variables and attributes more consistent names. You often use abbreviations, even though it is not necessary to do so and the use of abbreviations is not consistent.
- Some of the methods in elevator.rs are lengthy and hard to read. Especially the run_elevator method. You may refactor this method by breaking the functionality of this method into multiple methods with clear names that you can call from run_elevator. This refactor might also solve some code duplication. We suggest you at least outline the continuously polling default case of the match in the infinite loop. To avoid excessive nesting you may also make the code inside the loop its own method (being called repeatedly).
- Building on the last comment: it is great that at least part of the functionality in the main elevator loop is handled by floor_recieved, handle_cab_order, message_from_master, but we will suggest organizing the code in a way that make it clear that these are the functions handling receiving on the three associated channels. Perhaps simply by having consistent names for these like handle_x replacing x with a name relating to the channel it handles messages from.

