Reviewer 1:
6
- The code is chaotic and barely commented. You need to add comments and change the structure for other people to understand it. Ironically, the best commented part of the code is a test file which is commented in german.
- Threads are spawned in functions instead of the other way around. Most thread creations are also hidden away in auxillary files. These should all be moved to main to make the code easier to understand. Outside of the code copied from the elevator driver it seems like you only create one thread.
- I do not understand the necessity of the fsm and struct. Are you expecting to create multiple fsms or broadcasts on one PC? It's use makes the code horrible to read as nearly every line in fsm starts with self. This might work well, it just makes the functions harder to read.
- There is IMO way too much happening in the fsm thread. Almost all of the elevator functionality runs in this one thread. This should be split up and dealt with in separate threads.
- Also, while i don't quite understand how the watchdog function works, it seems unwise to be mixing arcs and tokio. I am also interested to know the reasoning behind the arc inside an option inside an mutex inside an arc. 
- The state system for the fsm is nice. It makes sense and makes the code decently understandable. But as the point above said, it should probably have some functionality split off for readability and for easier debugging.
- A few points you should look into: 
    - How do you confirm that other elevators have received an order to make sure it isn't lost? Right now there seems to be no verification of orders before they are completed. 
    - Also, how will you recover from a critical failure in one of the threads? I see that you have your watchdog, but it does not seem like any info is backed up right now. So given a panic in a thread, all the info used looks like it will be lost.
- In conclusion: It is clear that you have a lot of work to do. I can see the outline of what you want to do, but the implementation is very lacking.
- As for code quality, overall you would get a hard F from me. I should not need to work this hard to understand your code. It took me a long time to find out how you even wanted to communicate orders, and i have no idea what the broadcast functions even do currently as they do not seem to communicate with any other thread. Things that are missing should ideally be added as TODO! or at least explained in comments.

Reviewer 2:
8
*It seems you are using the old syntax for modules in Rust, you should prefer a lib.rs to split declaration and definition of modules and limit the use of old-fashioned mod.rs in every module directory.
* Great naming scheme for both functions and modules. Maybe use "elevator_fsm" over "fsm". 
* Main.rs is the entrypoint and details every subprocess/thread launched by the software. It is great to understand quickly what is launched and when. Some behaviors could be moved to a separate, dedicated function (f.ex. the initialization, and especially the event thread creation for the elevator hardware).
*Avoid too many global variables. A suggestion is to create an initialization struct with variables like floor number, etc.
* Design of BroadcastMsg seems very counterintuitive, at first, it is serializable so it is something you are going to pass over the network, but it also provides the capability to launch both the rx and tx part of the messaging system. It should be separated, as one messaging subsystem and a message struct that can contain every information you want to transmit. Otherwise, the design of the rest of the app is clear and readable, especially orderqueue.rs and fsm.rs. It is very easy to understand and every module deals with only one subject. The project is in an early state and only handles a single elevator, the server part is not finished but the structure is here.
* Navigation of the code is easy (files are rather small) and traceability is as well).
* Some code is very well documented/commented (orderqueue.rs) but some lack documentation, especially fsm.rs. Try to put a docstring on every function at least (tbf most of the functions I wrote are not documented yet so who am I to talk). Also, the comments are in German in watchdog.rs. ;)
* State seems local and most of the functions are pure enough (stay inside the scope of "self" and parameters). The flow is clear and is one direction only. State is stored at the right place where it is used.
* The implementation of a watchdog timer may be outside of the system requirements. If the watchdog timer's task is to revive the main program, this would be outside of the scope of the project, and it would be recommended to focus on other parts of the code beforehand. Also this requires the new program to be launched on the same computer, since launching a program on another computer through the network could be difficult due to security reasons. If the watchdog timer's task is simply to check if the main program is running, then a simple UDP-broadcasted heartbeat sequence between the programs could be enough.
* The implementation of an ENUM for direction values (instead of raw numbers for up, down and stop that is currently implemented) in the struct CurrentOrder would improve the code quality by making it easier for the reader to immediately see the purpose of the different values.
* In main.rs it is recommended to use handle.join().unwrap for the different threads instead of an empty loop, since the empty loop uses 100% CPU capacity without doing anything, and is therefore inefficient.
* Instead of writing “a” as a return parameter for the recv functions, it should be specified to improve readability. F.ex. “recv(self.floor_sensor_rx) -> a => {}” can be replaced with “recv(self.floor_sensor_rx) -> “floor_result”.

Reviewer 3:
8
- The main.rs file initializes key modules, making it clear what components exist, but, it would be beneficial to include a brief top-level comment explaining the overall architecture.
- The main.rs file sets up all the channels and threads very clearly, in a very readable format.
- The project uses structured module imports, keeping dependencies well-defined. Passing references explicitly instead of relying on global state in some places could improve maintainability.
- The finite state machine defines the core logic, and the structure suggests a master-driven approach. However, documenting how state transitions occur with comments would improve clarity.
- Most modules adhere to a single responsibility, for example buttons.rs handles button-related logic, and this improves the understandability of your code.
- The modules appear functionally complete, though there is no clear mechanism for handling network failures in server.rs. Some form of failure handling would be beneficial.
- Most functions are well-structured and avoid side effects. Some functions in fsm.rs could benefit from more explicit return values instead of modifying state internally.
- The code is readable, with consistent formatting and reasonable variable names. Some deeply nested match statements in fsm.rs could be refactored for clarity.
- Comments exist but are sparse in critical areas. Adding more explanatory comments about network message handling would be useful.
- The project is well-structured and maintainable, with some minor issues related to documentation and state encapsulation. Overall, it is a solid implementation that could be improved with additional clarity in specific areas.

Reviewer 4:
8
- The main function clearly sets up the FSM, sensors, buttons, and communication threads.
-  Separate modules exist for lights, floors, and buttons, but they seem underutilized. Light control still happens inside the FSM, and floors.rs and buttons.rs is empty
-  FSM states appear clearly structured, making it easier to understand the elevator's intended behavior, such as `MOVING`, `DOOR_OPEN`, and `SET_TARGET_FLOOR`.
-  Order queue is well-structured, with a clear separation between cab and hall calls. The `add_order` and `remove_order` functions make it easy to manage orders efficiently.
-  UDP communication is started, but it’s currently quite basic and not yet clearly connected to the rest of the elevator logic.
- Watchdog integration is unclear – It only prints `"Watchdog timed out!"` with no recovery action. 
-  Overall, the communication infrastructure is well on its way, although additional work remains on message handling logic and
integration with the rest of the elevator system.

Reviewer 5:
5
-Buttons, floors and lights just include elevio and does not need to be its own files and folders
-Make a lib file where you include modules, rather than a folder for each file where you include a mod file for only one other file. 
 Also, do not use mod ... in main, but access it through the crate created by the lib file using crate_name::module:: as you do with all external crates (e.g. std::sync::{})
-You should not apply queues in the classical understanding of queues. It is hard  to tell if you intend to or not, since you have not used it yet, only made an instance as an element of other components. 
 But by your functions it looks like you are going to. I recommend you to check out the cost_fns in the course resources on github.
-Elevio.poll threads should not be called in main but rather its own module
-State action is a very big function now which seems to do a lot of different things. It would be more readable if this function was divided into multiple smaller functions each with a specific role.
-From the code it is very difficult to tell if you’re planning on using P2P or master-slave and if you’re planning on using TCP or UDP. Make sure you make a plan on how to do this before you proceed.
-In general, it looks like the code is a mix of the different exercises where you’ve tried to connect them together. It would probably be easier to start off with only the single elevator and build on that.

