Reviewer 1:
6
-	There is a lot of hard-coded assumptions in the code. While some of the assumptions such as
	number of floors and number of elevators can be argued to be reasonable for this specific
	project, the recommendation in the project description, and just general best practice, is to
	avoid these assumptions. It makes code less flexible and harder to adapt to changes to specs.
-	The project would benefit from using @spec to specify both for the programmer and compiler
	what types the inputs and outputs are. It is not easy to guess, especially for functions
	that take 4+ parameters, what types all the parameters are. Adding @spec will also let the
	compiler help with detecting faults in the code. Likewise @doc is treated as a first class
	citizen in elixir, but is fully missing from the project. @doc and @docmodule would be helpful
	particularly for the functions that interact and mutates state in the controller module as it
	isn't always clear what all their side effects are.
-	Elixir has support for module structs. This construct can help with making it clear what format
	the GenServer state uses and would make it clearer what state the GenServer tracks.
	It also supports @enforce_keys which can help with catching errors if a mutation in state
	doesn't include one of the required keys. In the same vein, @type can be used to further define
	the struct and make it clear what types each key in the struct contain. It's elixir convention
	that a module type is called t (Module.t()). This also plays well with usage in @spec.
	This is greatly needed for the controller state as it's hard to keep track of such a big map.
-	Hiding internal modules via import is generally discouraged in elixir as you hide the source
	of the function. Instead you should either directly call the function with its module name
	`Module.function_call()` or use alias to make the module name shorter, while still showing
	the source of the function definition. It would have made it easier to see what modules you
	are calling and where. Importing modules is also not required in elixir the same way
	they are in C or Python, the module will always be available in all other modules if it is
	available in the project at compile time.
	https://hexdocs.pm/elixir/1.17.3/alias-require-and-import.html
-	should_stop? should be simplified from a hard-to-read triple nested if statement into a single
	if statement. The format `if boolean_function(), do: true, else: false` is overly complicated
	when `boolean_function()` can just be returned as is. A similar situation happens in
	number_of_orders().
-	Elixir ships with mix which has an official style guide that you can automatically comply with
	by calling `mix format` in your mix project. It is highly encouraged to follow this style to
	stay consistent with all other elixir projects. It makes it a lot easier for people used to
	the official style guide to read and understand your code at a glance, on top of also being a
	community curated and sensible style to follow in elixir. Personally, the code became a lot
	more readable after running mix format to get it to a familiar style.
	https://github.com/christopheradams/elixir_style_guide
-	GenServer is primarily used to maintain state of a process, and enforces certain limitations
	such as poor scalability as calls to it increases, i.e. it's a single threaded process that
	locks you out of concurrency for its functions. As such it's discouraged to use GenServer
	if you don't have any state to maintain. Your module requests.ex currently does not look like
	it needs to maintain a state, and as such you should consider discarding the GenServer behavior.
	Since it's currently only called from another GenServer process, this isn't a huge concern
	for you, but if a redesign of the controller enabled concurrent calls to requests.ex, it would
	lead to a needless bottleneck.
	If your plan was to use GenServer to get access to GenServer.call/3 and GenServer.cast/2, you
	can achieve the same using the built-in remote procedure call service via :rpc.call/4 and
	:rpc.cast/4.
-	You are often passing the whole "fsm" map (which really is the elevator data, not a
	finite state machine as the name suggests) to functions that only require a couple variables.
	There are a couple problems with this approach. First and foremost it leads to tight coupling
	between functions in other modules and the GenServer state of controller.ex. It will make it
	difficult for you to refactor controller.ex as multiple modules relies on the state in
	controller, so a refactor of controller will require a refactor of util, fsm, requests, and
	potentially poller (it's sending all data to a single process in controller.ex).
	A quick example, if you were to rename the key "assigned_hall_requests", you would break
	6 functions in 2 other modules. Renaming "floor_integer" would break 10 functions in 3 other
	modules and is referenced 15 times outside its module. That's pretty much the whole project.
	The map fsm's structure is also not defined anywhere, it should ideally be a struct so that it
	got well-defined keys. This would also allow the compiler to warn you if you do a refactor and
	accidentally break half of your functions due to moving or renaming a key.
	It might be worth asking if the controller is controlling too much and if you would benefit from
	splitting up its responsibilities into multiple modules. Less code and fewer modules doesn't
	necessarily mean less complexity, often the opposite. Simple made easy that Ander's recommended
	is genuinely a useful talk to watch on this topic.
	https://www.infoq.com/presentations/Simple-Made-Easy/
	Keep your pure functions simple and only pass the data they need.
-	You're not actually using the Driver API as it's intended to use, instead you're exposing the
	underlying GenServer implementation of the driver. While this works fine for this project,
	it's generally bad practice, as the purpose of an API is to provide a standardised interface
	while the underlying implementation can be modified.
-	A note on your usage of the GenServer API. GenServer recommends to use GenServer.call/3 by
	default, and only use cast when it's explicitly needed. This is to create backpressure and avoid
	you from filling up the mailbox of the GenServer process, which could lead to heavily degraded
	performance. You are also casting to your own GenServer from within the GenServer. This is
	perfectly fine, but be aware that you aren't running those processes and updating the state
	until the event you're in is completed.
-	A little tip not directly related to code quality: GenServer has a function called abcast, it's
	the cast equivalent of multi_call, there is no need to manually loop over each node in
	[Node.self() | Node.list()] and call cast.

