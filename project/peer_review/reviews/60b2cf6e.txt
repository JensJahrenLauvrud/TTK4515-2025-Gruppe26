Reviewer 1:
8
In general; a very clean code, and function and variable names are descriptive. Very clean with such short main.
I like the single_elevator folder, it is very easy to understand what is done and clean to have all functionality regarding one elevator gathered, but:
The switch case in finalfsm.go is a little hard to follow, much happening in what seems like random orders. Also cases I expected, that never showed. Like behavior being idle. 
Number of elevators are defined as a const in "configuration.go" this contradicts the recommendation that says "You should be able to add a fourth elevator with no extra configuration" in the project description
Clever with a default behavior to be unknown in the behavior case (func ToString)
How will OrderCompletedatCurrentFloor work? How is the elevator ever moving when clearing an order? Shouldn't it be standing still waiting for the door to close when the order is complete?
Consider changing the name of the file main.go in the network folder. It should only be one main


Reviewer 2:
6
The low rating comes from the fact that this project is very far from actually realizing a working distributed elevator system. 
As much of the code is “unfinished” and “not implemented yet”, so it is difficult to understand how the system is meant to work.
We have still compiled some feedback on the existing code below:
The elevator handout is nicely translated and easy to follow
The project structure is nice, it is easy to navigate the modules which build up the system. In worldviewManager, you define ElevStatesMsg, and in config you define OrderMsg. Maybe these should be defined in the same package, perhaps in communication. 
There could also have been more documentation of functions, and what they do. It is not always obvious what is happening since there is no explanation about the function of your functions. For example, in WorldViewFunc.go, updateWorldViewWithButton takes in a bool B that is unclear what indicates. This function can be divided into to removeOrderFromWorldView and addOrderToWorldView.
In general, the world view package is difficult to give feedback on, as the code is unfinished and contains obsolete code.  
Some of your modules mix different types of functionality, for example in finalFSM there are functions like toString, creation of structs, maybe this could be moved to package elevio where you define similar functions and structs.
The communication package has no documentation, however it has clear names and its easy to understand which channels are being used and which network protocol you are using.
You have a tidy config file where you set values to variables that are being used throughout the project, the names are clear and we can understand what the variables do based on their names.

Reviewer 3:
7
- Main: Some logic appears to be missing. Currently, it initializes and starts polling buttons for a single elevator. With the system structure you have chosen there shouldn’t be an issue with this, though the order_manager should also be there. Also it seems like you lack an overall elevator FSM, which would be the main task to handle by the main.go package. It seems this logic is baked into worldviewmanager?
- Single elevator: Be cautious with how many goroutines are started and where they are initiated. While Go is more forgiving than C, excessive goroutines can still lead to CPU strain. Also, consider breaking the singleElevator function into smaller, more modular functions to improve maintainability.
- Network: No modifications have been made yet, so here are some recommendations: Running the network as a separate module with channel-based communication is problematic because Go channels only work within the same goprocess. As different goprocesses, they have to communicate over the localhost network, which we don't recommend. Instead, networking should be integrated into the main goprocess. Also try to abstract the networking away from other parts of the project as much as possible, so that worldviewManager only needs to start a routine for “listening”, then use a network.Send(worldview) function on a fixed rate. Additionally: Consider the structuring of your messages and ensure they are serialized and deserialized efficiently. Consider using timestamps in messages to detect disconnected elevators.
- WorldView: The approach to handling worldviews is well thought out and clearly documented. The plan for order requests is also solid. It sounds simple and elegant that everyone knows each other's status at all times. However, consider adding timestamps to prevent outdated data issues. Also if everyone always knows each other's worldviews, do you need ack signals? Instead of using explicit ack signals, consider using the broadcasted worldviews to determine if an order has been received.
- Modularity: File names are at times not very descriptive and functionality seems misplaced. Improve modularity by making subfolders. The project code feels “hard coded” at times, which is usually a sign of little modularity. As stated, we recommend that you create smaller functions with descriptive names and divide up the logic in smaller parts, giving you a codebase that works essentially as a “lego set”. This has already been done pretty well in the worldview directory.
- Code quality: Ensure consistent capitalization for function names; functions meant for external packages should be capitalized.

Reviewer 4:
6
1. Folder structure is somewhat messy, and some unused files are leading to unclarity. An example of this is the three different main.go files that are located in different folders.
2. A lot of uncompleted code makes it hard to give feedback on the system design. 
3. Goroutines inside goroutines in single elevator, making the code structure unclear and may be difficult to debug.
4. Not clear from the project architecture file how an elevator is going to handle a reconnect in terms of the cyclic counter logic for orders.
5. Nice with communication across modules using predefined channels with specified direction for information flow. This prevents unintended usage of the channels, making debugging easier.  
6. Config-module: Good solution for using the same variables in different modules and avoiding import-cycles.
7. Functionality looks well distributed over the different modules and appears to have modular "run functions". 

