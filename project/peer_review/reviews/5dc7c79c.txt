Reviewer 1:
5
There is no documentation. Try to document what each function is supposed to do - either via comments or via a documentation file. (See doxygen, or markdown). This helps readability of code and maintainability as it becomes clearer what each module / function / global variable / struct is supposed to do.
There is no module separation - the module for moving a single elevator and the module for handling orders are intertwined and overlapping in package main. I recommend rewriting in such a way where these are separate. I.e. The single elevator module accepts a command “Go to floor X”, while a new Orders module issues the command, the Main module should create an instance of both of these modules and connect them using go channels or hierarchy where Orders “own” the single elevator.
The global variables which are supposed to be locked behind a mutex are exposed - elevatorOrders, posArray and ableToCloseDoors are all directly accessible, even without locking the mutex. I recommend enclosing the variables in a struct and creating functions for the struct that handles the mutex while changing the contents automatically for you. i.e. “ElevatorOrders.” This helps because it makes it impossible to accidentally access a mutex variable without locking the mutex. Also makes the code more readable as it removes the seemingly random calls to locking and unlocking the mutex.
Functions are in general too big - A function should ideally try to do 1 thing, and 1 thing only. This isn’t always possible, but striving for decoupling makes the code easier to create and also easier to maintain. Example: Main is currently handling initialization of the elevator and then proceeds to handle button/switch calls from the elevio. Effectively main is doing 2 separate things, and it is most certainly possible to separate the handling of button/switch calls and the initialization, if not out of main then into separate functions that main calls. Additionally, your switch/select case statements should ideally be small, if the code in a case is long, try creating a new function that does what the contents of that case. In main there is a go-routine you’re starting that effectively works the same as an inline code snippet because you’re waiting for drv_finishedInitialization to be called, which is called at the end of the go-routine. Effectively making it a procedural code instead of concurrent code which a go-routine is supposed to handle. Was this intentional? Remember, main is also a go-routine.
Variable naming - Some variables have good names! ableToLockDoors makes sense as a name, and I can tell what it means, and where it is used makes sense. In contrast you have a variable called “first_element” in main. What is this variable supposed to be? Given it’s small scope I can somewhat tell, but I recommend even for variables with such a small scope to have better naming (exceptions apply where it is completely obvious). Also, first_element is using snake_case while ableToLockDoors is using camelCase. Try to be consistent in naming convention. Your constants are using PascalCase, I recommend switching away from this as Go exports anything that starts with a large letter, and unless you intend to confuse your exported functions and constants I recommend one of the all-caps case conventions for constants.
Function naming - Most functions have confusing names that don’t necessarily make sense. What does sortAllOrders actually do? From its name I expect it to sort from lowest floor to highest floor. It does not sort the orders from lowest to highest floor or the opposite direction, but something that looks like it sorts orders by how important they are? I recommend giving it a name and making sure it does what its name says it does.
Networking & States - You have not begun your network module yet. I strongly suggest you get this started as it will change how you’re currently doing the elevator code.

Reviewer 2:
7
The code contains useful comments, but some comments are unneccessary. For example, in utils.go, a comment is added above orderTypeToString that says "Helper function to convert orderType to string". The function name communicates the purpose of the function so the comment is not neccessary. Using Doxygen comments for the functions in the code is probably a better idea
There is inconsistency between the usage of snake_case PascalCase and camelCase. For example the turnOffLights function in main.go has two parameters, the first one is written in snake_case while the other is written in camelCase. 
util.go contains multiple functions related to orders. Since these functions are related to orders, they should rather be placed in handleOrders.go
The system lacks network communication and a design choice on whether the system uses a master/slave architecture or a peer to peer architechture has not been decided. It is understandble that the system is not done, but these design choices should be made at this point in the project. 
It is a great design choice to not have global variables in the handleOrders.go module and the util.go module. This makes it easy to track changes in the state of the system.
The code has a good structure and is very readable. Most of the variable names are descriptive (For example, in util.go, in the trackPosition function, a variable called "a" is used. The name should be changed to something more descriptive).
In the extractPos function in util.go, a float32 is used. The constant swapping between float32 and int is confusing. 

