Reviewer 1:
8
bullet point 1: Consider using a configuration file to avoid global variables. Note that CALL_COUNT is defined several times. On the other hand, the global configuration variables are few and have good names.
bullet point 2: There is a good description of how the elevator system works. However, it is somewhat unclear whether this is a master–slave system or a peer-to-peer system. Whith a manager, but have message broadcasting.
bullet point 3: The queues for both the manager and the individual elevators are declared as public types and are almost hidden in the code. Try to make it clearer that these are the queues by adding a comment and providing more space for them in the code.
bullet point 4: The state machine structure is good, with clear function names and an understandable program flow.
bullet point 5: Some hard-coded configuration variables, such as "let elev_num_floors = 4" in main.rs, should be easily fixable.
bullet point 6: The code is nicely commented, with few unnecessary comments and concise remarks where needed.
bullet point 7: It is smart to separate the network code from the elevator logic, but this could probably also be done in a separate module or file.
bullet point 8: It does not seem clear to me how you handle failures and errors. Rust's error handling mechanisms are not used extensively, and the program would probably panic in many situations.

Reviewer 2:
7
- The project's concurrency structure using `crossbeam_channel` is functional and straightforward, but the decision not to use an asynchronous runtime like Tokio is a significant missed opportunity. Using Tokio’s asynchronous runtime would considerably improve scalability, CPU utilization, and responsiveness, especially if the project grows in complexity or elevator count.
- The FSM implementation (`fsm.rs`) shows good use of Rust enums and state management patterns, though some logic is duplicated or verbose, such as repeated match patterns, indicating possibilities for simplification through more abstraction or helper methods.
- Overall, the system's concurrency model with threads and channels is clear, but the use of synchronous `std::thread::sleep()` for timing (`alarm.rs`, `fsm.rs`) limits scalability. Transitioning to asynchronous timers would greatly improve responsiveness and resource usage.
- Error handling is inconsistent and somewhat unsafe; several `.unwrap()` statements in critical network operations (e.g., in `sender.rs`, `receiver.rs`, and `network.rs`) risk panics without proper context or recovery strategies, reducing reliability significantly.
- The project structure is clear, and code modularity is good (`manager.rs`, `controller.rs`, etc.), facilitating ease of navigation and maintainability. However, some critical functionality (e.g., handling network state synchronization) lacks sufficient explanatory comments, hindering quick understanding of intent or reasoning.
- Good adherence to Rust conventions overall, but better encapsulation and stricter management of shared state could improve maintainability. For example, mutable shared state (like the elevator `WorldView` structure) could be better protected or refactored to reduce potential race conditions or complexity.
- Magic numbers are partly mitigated through a centralized configuration file (`config.rs`), yet certain timeouts or configuration parameters scattered in multiple modules remain hard-coded and should be consolidated to improve maintainability and clarity.

Reviewer 3:
9
* Main entrypoint is easy to read and point to every useful submodule. Flow of state seems to be one direction only and the state is local.
* Every module handles a specific task, and only this task. This makes the code easier to read and comprehend. Diagram and README-file help a lot when navigating the code.
* Many comments are present but some parts are totally undocumented, especially on State changes and branching.
* Naming is great, with every module being self-explanatory and functions too. This makes navigation/comprehension easier as well. The only recommended change could be specifying the return parameters of recv() functions. (F.ex. recv(call_button_rx) -> a, where “a” should be replaced by the return type or a more descriptive variable name).
* The global design of the application is relevant and makes sense, it seems to be a peer-to-peer architecture with every elevator being synchronized with every other elevator over UDP.
* The project is in an advanced state, with networking and FSM operational, Docker configuration helps a lot to test the code as well.
* Are you running two programs per PC (network and general)? Since you have two main files, this looks unnecessary and can increase the probability of failure. 
* Don’t understand why you are creating clones of, for example, alarm_rx instead of using alarm_rx directly? Not necessary unless you're also using alarm_rx in another thread. OBS: The issue with this is that only one of the threads will receive and read the message. After that, it "disappears" before the other thread can read it.
* A lot of code in main.rs. Argument handling in main can be its own function. Also, some of the elevator initialization code could be implemented as an initialization function for an Elevator/Controller Struct to make the code more readable.
* Only UDP is implemented. Acknowledgement is implemented, giving a similar functionality as it would be to use TCP directly. While UDP may minimize latency, this implementation could be a potential source for errors. Maybe consider looking into some of the benefits of using TCP as well as UDP.


Reviewer 4:
8
- Network addresses and ports are hard-coded, I would suggest some file for all configs
- There are some similarities in sender and receiver in the code, which can be abstracted.
- FSM logic is a bit complex to understand. Maybe there is a way to simplify or at least add some comments?
- Overall the project is well modularized
- Naming of variables and functions is good

