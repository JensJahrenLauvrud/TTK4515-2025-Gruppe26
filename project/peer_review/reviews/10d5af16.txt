Reviewer 1:
6
- Consider using structure methods in all code, to mimic OOP behaviour, to tidy code up (https://go.dev/tour/methods/1)
- You use `fmt.Println()` and `fmt.Printf()` interchangeably, consider using a logging library and or sticking to one of print functions
- Lack of error handling, consider adding more functionality around that. I notice sometimes you print to terminal on error while at times exit function
- High reliance on strings for example, `switch e.Config.ClearRequestVariant { case "CV_All":` and `var ElevatorBehaviourToString = map[ElevatorBehaviour]string{`. Consider using enums for this, rather than stringifying it and comparing it. It will increase performance, readability and maintainability.
- Consider having one main file with all constants that you import to each file, to avoid magic numbers like `numFloors := 4`
- Contents of `timer.go` file can potentially be placed inside `select` in `ElevLogic_runElevator` function.
- Two threads write/read from global variable `allElevStates`, although this works, its a bit messy with mutex lock/unlock. Consider giving ownership of the variable to one thread and creating a channel between them if it needs to be
- Inside the main file, you determine slave/master functionality, through `if len(os.Args) > 1 && os.Args[1] == "slave"`. Consider creating a function for this like `conn = comm.CommSpawnElevator(os.Args[1])`, that checks internally.
- `Elevator_uninitialized` function looks very messy and not maintainable. Consider refactoring the code so that you define the initiliased state rather than uninitialised state.
- Clean up redundand functions `Wrap_request_button_light` and `Elevator_hardware_set_button_lamp` and `elevio.SetButtonLamp` do the same thing.
- Clean up `Init` function in `elevator_io_device.go`, since it calls `Elevator_hardware_init`
- Consider using golang function naming convention. For example `Comm_slaveConnectToMaster` does not follow the standard naming convention
- Components do mostly, how they are named, but some abbreviations are not obvious, like what is meaning of `hra` in `hraAssigner.go`?
- Functionality is ok overall, can find my way around the project
- Coherance is also ok, each module plays its own role and is not too big.
- Completeness, the project is not finished, but appears to implement the right functionality for the elevator
- State, in some parts of the code is ok, in others its not, i would focus on what thread/function takes ownership of what variable, and try not to share too many variables across different functions
- Functions sometimes modify global variable, would focus on fixing this.
- Body of code is a bit complex in some instances, especially initialisation. I would try to improve this. In orders its ok, like FSM.
- Understandibility is overall ok, all variables have readable names but some dont adhere to naming conventions
- Traceability is questionable, since many functions share global variables.
- Direction, some code is redudant and contains nested function, that calls other subsequent functions with no point. For example FooBar(x) -> BarFoo(x) -> FooFoo(x). No need for this

Reviewer 2:
7
- The codebase is well-structured into modules (elevator_logic, fsm, request, etc.), but it is unclear how some modules depend on each other. For example, elevator_logic.go has a strong dependency on fsm.go without making this explicit.
- Some functions have inconsistent naming, such as Eb_toString and Logic_runElevator in elevator_logic.go, which use snake_case, while all functions in elevator_io follow camelCase.
- Complex functions like MasterLogic_runHRAUpdater and ElevLogic_runElevator have limited documentation despite their complexity. Comments throughout the project are also in both Norwegian and English; you should stick to one language.
- In elevator.go, N_FLOORS is defined as 4, while in elevator_io.go, const _numFloors = 4 is used. These values, along with other global constants, could be gathered in a configuration file or a global constants file to ensure consistency.
- In master_logic.go, a global map is used for allElevStates, but only a single mutex protects access. Multiple goroutines read and write to shared data structures, and without proper locking, this can lead to data races. Be mindful of this in further development.
- Some functions have too broad a responsibility. For example, MasterLogic_handleElevatorConnection handles logging, status updates, and error handling within a single function. This could be split into validateConnection, updateElevatorState, and logConnectionStatus to achieve better functional cohesion.
- The project has a generally good foundational structure, with clearly defined modules, and it is evident that a specific design method has been chosen (Master-Slave with backup).

Reviewer 3:
8
Bullet point 1: Components
The main function initializes the elevator system and starts the elevator logic, but you should include some comments during the code, which describes what each part does. 
On the other hand, the README.md-file is very informative and easy to understand. 
It is a good file to have when you are reading through the structure and donâ€™t quite understand what a file does in the system.
Bullet point 2: Dependencies
The code successfully establishes connections and initializes the elevator I/O, demonstrating a clear understanding of the system's dependencies. Great job on this! 
To enhance this further, consider adding comments to explain the interaction between communication, elevator, elevator_io_device, and elevator_logic, making the dependencies more transparent.
Bullet point 3: Functionality
The code indicates a master-slave architecture with TCP for communication, which is also stated in the README-file. 
This is a solid approach, and it seems that you have a good starting point with the MasterLogic-function. 
Continuing forward you should consider adding documentation to explain how orders are assigned, executed, or backed up.
Bullet point 4: Coherence
The main function handles multiple responsibilities, such as connection handling, elevator initialization, and running the elevator logic. 
This shows a good grasp of the system's requirements. 
To improve coherence, you should consider moving the code into distinct functions, making the codebase more modular and maintainable.
Bullet point 5: State
The state of the elevator system is managed through the FSM instance, which is good practice. 
To further enhance state management, add comments to clarify who is responsible for each piece of state and minimize shared state across threads, ensuring a more robust and maintainable system.
Bullet point 6: Understandability
The code is relatively easy to follow, and the use of standard packages and functions is a good way to structure the code. 
To make the code even more understandable, improve variable names (e.g., fsm, conn) and add comments to explain the logic, helping future developers quickly grasp the code's purpose and functionality. 
The README.md provides useful information about the architecture and modules, which helps a lot during further development of the code.
Bullet point 7: Traceability
The flow of information, such as establishing connections and running the elevator logic, can be better documented. 
Adding comments to trace the flow of events, like a button press leading to the elevator moving, would make it easier to debug and understand the system.

Reviewer 4:
7
-README Details: The README file gives an overview of the project, but it could include more details. For example, it could explain how the modules communicate with each other and provide more context about the system's architecture and data flow.
-Code Comments: The understandability of the code could be improved by adding more comments. This would help explain the purpose of key sections and make the code easier to follow.
-Details about order assignment, acknowledgement procedures, and order backups are not immediately clear from the main.go file and README.
-Acknowledgement and Backup Implementation: There is no implementation of acknowledgements and backups in the project, aside from a brief mention in the README. Don't forget to implement these features.
-Master Logic Functions: It is unclear where functions like MasterLogic_runHRAUpdater() from master_logic.go are intended to be used. Clarify whether these functions will be called from main.go or elsewhere, and provide a clear plan for their implementation and usage.
-Elevator Logic Module: The elevator_logic module is somewhat confusing. Consider splitting the master logic and the "normal" elevator logic into separate modules. This would help in organizing the code better and making the responsibilities of each module clearer.
-Module Hierarchy: You have many modules on the same level. To make the module relationships clearer, consider organizing all the modules that are used to run a single elevator as submodules under a single elevator module. This would help in understanding the dependencies and interactions between different components more easily.

