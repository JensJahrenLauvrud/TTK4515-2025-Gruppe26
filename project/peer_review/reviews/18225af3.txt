Reviewer 1:
9
The overall organization of the project is very clean and thoughtfully arranged. Each component focuses on a specific responsibility, making the codebase easy to understand and maintain. The structure encourages clear communication between parts of the system without excessive overlap or tangled dependencies, which is a strong indicator of good software engineering practices.  
The heartbeat mechanism over UDP is well-implemented. Periodic signals and peer monitoring make the system resilient, and the promotion logic to handle a missing master is a great fault-tolerance strategy. The queue mechanism is a straightforward queue manager that ties in well with the asynchronous nature of the networked setup, responding to incoming requests without mixing higher-level logic, which keeps the overall codebase neat and modular.  
The JSON-based message protocol ensures consistent and clear data interchange between different parts of the system. This approach makes debugging easier and lays the groundwork for adding more message types in the future without disrupting existing functionality.  
The dynamic queue manager in the code helps handle new requests efficiently by separating scheduling concerns from lower-level hardware operations. This separation keeps the request flow cohesive and reduces complexity in the main application.  
The robust handling of missing backups by promotion logic allows good role transitions. This built-in redundancy helps the system maintain stability even if one part fails.
By dividing tasks into distinct modules—such as transport, messaging, and queue management—the codebase stays organized. Each area can be tested independently, improving maintainability and reducing the risk of unexpected side effects.  
Overall, the design remains highly extensible, so new features or modifications can be integrated without restructuring the entire codebase. This adaptability, combined with the strong fault tolerance, demonstrates a thorough understanding of good software engineering practices.

Reviewer 2:
7
- Overall Structure: The project is divided into multiple folders (e.g., app, cmd, pkg), and each subfolder targets a specific functionality (like elevator FSM in pkg/elevator and networking in pkg/transport). While this division aids in finding code, the deep nesting can feel somewhat disorganized, making the overall architecture harder to grasp at a glance.
- Entry Points: The cmd/main/main.go file defines the main executable, while app.go handles coordination logic (heartbeat, state broadcasting). This is consistent with standard Go project layouts.
- Configuration & Global Constants: It’s a good practice that configuration details (addresses, NumFloors, TCP/UDP ports, and even constants like travelTime and doorOpenTime) are centralized in config.go. This creates a single source of truth, though a more structured configuration (e.g., via JSON or a config struct) might improve maintainability.
- Concurrency with Channels: The code leverages channels for hardware polling (buttons, floor sensors) and message handling, which is idiomatic in Go.
- Naming & Idiomatic Go: Some identifiers do not conform to standard Go naming conventions. For example, constants like "Num_floors" and "Door_open_duration". Adopting conventional Go naming (e.g., NumFloors, DoorOpenDuration) would improve clarity and consistency.

Reviewer 3:
9
- Great README. Overall the codebase seems very reasonable. Layout is clean, no cluttering in main.
- The master module contains network handling, consider including this in the transport module instead. Also, the network hand out module has modular functions for transmitting and receiving, which could've been used. This is not a "dig", but resources might have been better spent elsewhere (e.g. multiple elevator order assignment).
- I would consider switching from mutexes to channel implementation for concurrent safe access. Mutexes work absolutely fine, but I think the channel implementation is elegant and makes use of Go's best features.
- state.GetAll and similar functions show that you understand the importance of thread-safety.
- The polling approach you have chosen is inefficient, as you are aware of. Implementing a fully event-driven polling system for functions like fsm.Run is smart.
- It looks like you currently open a new udp connection for every message sent. This could be improved greatly by reusing established connections.
- Channels should be buffered to improve robustness. (app:120-123) In the case of bugs and/or high traffic, goroutines could deadlock.
- Having type declarations at the top of files makes sense and would be more readable than the current approach.


Reviewer 4:
8
It is not obvious whether this is a peer-to-peer or master-slave system, purely from looking at the main.go-file.
How you handle orders is confusing. There is an order-module, but there is also an OptimalOrder.go-file in the elevator-module. Perhaps the naming should be improved here, to differentiate between distributing orders between elevators and determining how a single elevator should take its orders. 
How state is stored is a bit confusing. What is the state of the local elevator, and what data is shared?
The way you have defined variables like elevatorFSM and requestMatrix in main.go, and then pass them as parameters to their relevant threads and functions, is very clean. I would rate the traceability and direction highly here, as it is very easy to follow the variables through their threads. 
The code is generally very understandable. Most functions are easy to understand. In FSM however, there are some cases where there is significant nesting of if-statements and switches. This might be hard to avoid, as elevator-logic might require this sort code, but it should be looked into. Especially the function checkAndAssignOptimalOrder().
The documentation is good. Having a document that gives an overview of the different modules makes reading the code easier. There are however not many comments in the code itself. This should be considered. 
The coherence between threads is done well, and the structure is made very clear. Threads and functions seem to only do one task, of course with the exception of large functions like RunEventLoop() and FSM. This structure is good. How you handle order assigning might be an exception here though.

