Reviewer 1:
7
-The entry point (main) documents what modules the system consists of. It is easy to see that master-slave is used.
-It is also well documented how the modules are connected because of the channels made in main. 
-The functionality was pretty good. However, the group could place all the network functionality for the master-module in the same place and pass the channels to the 
relevant modules. The same is relevant for the slave-module. 
-The name "fsm_fsm" for the first function in "fsm.go" can be more describing. In addition, the "io.go" and the "fsm.go" could be combined into only one fsm as it looks like they both deal with change of states of the elevator. 
-It was difficult to find the distribution part of the code. Should make this more obvious.
-Should change the name of the folder named "peers" inside the folder "network" and all use of "peers" should be avoided as it is confusing when master-slave is used. 
-Should rename file called "lookFor.go" in the folder called "master" as it is difficult to understand what it is looking for.
-The file called "network.go" inside the folder "slave" was a bit messy. For example: "tx := make(chan EventMessage)" and "var out EventMessage", should be renamed to something more describing. It was therefore difficult to follow the flow from for example a button press to the moving of an elevator.

Reviewer 2:
9
Good documentation. Many explanatory comments and README files in each module make the code more understandable. Function names and channels clearly reflect the chosen design. 
Good use of channels and select blocks. Makes the code very structured. 
Great that the number of buttons/floors is not hardcoded. This aids with potentially increasing the size of the program or adding new features. 
Use of shared global data structures and states can make the system vulnerable to incorrect updates. Use of impure functions that modify external values may also cause issues. 
Some select blocks use default. This can lead to busy waiting and inefficient CPU usage. 
Well-structured data structures for representing elevator states. 
The code appears solid and well-thought-out, with good modularity and scalability. 

Reviewer 3:
8
 - The process tree (which processes are running) is quite complex and has a lot of branches (There are many goroutines which spawn their own goroutines etc...). If possible try to spawn threads from one of the top-level entry points
 - The communication between threads is mostly clear (which channels are being passed where, no global variables, etc..) and functions are mostly kept pure, which is good. However, note that passing channels into functions which aren't called as goroutines is generally not a good idea, because you lose track of where things are being written to or read from this channel (ideally with process-oriented programs, you only read and write to channels in the process itself).
 - The function bodies are generally easy to follow, but consider simplifying the logic in the select cases themselves, it's hard to read and for instance mainLoop in backupComm.go seems to have some confusing decisions (why so many select statements??). Also, some of the code blocks are very highly nested, which makes them hard to read.
 - Structure is logical, it's easy to navigate and find the different components of the system. Also you've done a good job at exposing the right amount of functionality, however one piece of feedback could be to for example make the elevator module a submodule of the slave module (it's a bit confusing to see BT_down and such when looking in the slave module) (nitpick)
 - It is in some cases unclear whether data is shared between threads (ref: network.go, why is there a mutex?) Instead of saying that it probably isn't necessary, try to detect and resolve any race conditions. If you don't already know, go has a built-in race condition detector that you can use with go run -race [youfile.go]. Having a mutex which prbably isn't needed is a sign that the flow of data is unclear, and perhaps that tings could be simplified
 - The flow of information is very hard to trace due to the interconnectedness of the entire codebase. We tried to trace what happens when a button is pressed, but the information is passed around in so many places that it's very hard to understand where it actually ends up and who handles it. This indicates that the project might be a bit overengineered.
 - The comments in this case are very useful to get an overwiev of what the code does, even though they are might be a bit superfluous in some cases. In general however, since this system is quite complex and large in scope, the comments and README files are a very good resource for understanding the code.
 - Naming is very confusing in some cases, for instance we have a tx channel (with no indication of what the message type is) which is passed into network_sender as outgoing, but then in network_sender we have a new tx, which *also* has no indication as to what it's used for, and so it's very easy to confuse these two when trying to trace the flow of information
 - Gut feeling: 6. The project seems overall well written, it's clear that you're using the process-oriented approach as well as the functional core/imperative shell approach, however, it doesn't look like you've executed these approaches perfectly. Also, the project seems to have grown very large, and maybe overengineered. We haven't checked the program for bugs, but if one was to appear, we would not be thrilled about needing to search through the codebase to find it, as it's very hard to follow the flow of information. Therefore, we recommend that you try to simplify and maybe reduce the interconnectedness of the codebase.

Reviewer 4:
8
The run.sh auto-restart logic works, but rewriting it in Go would align better with the project's Go-centric design and avoid Bash dependency.
Clean master/slave split with tidy startup in slave.go/master.go, channels and goroutines make sense.
makeRemoveCallsUpdate does its job but clearCompletedCalls would clarify intent (removes fulfilled orders).
FSM and network retries (resending acks) keep behavior stable and predictable.
READMEs explain flow, but docs for edge cases would help debugging.
Feels sturdy overall, minor tweaks would make it perfect.

