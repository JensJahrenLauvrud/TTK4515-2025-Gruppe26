Reviewer 1:
8
-	From the top-level entry point it gives a good enough understanding of the complete structure of the code. We got an understanding of how the elevator should work with the controller and different nodes. 
-	The modules are designed coherently and only deal with one subject.  We don't get overwhelmed when looking at them. 
-	Think about how you continue expanding the main functionality. It might be smart to add sub-functionality or other functions to declutter the main files. Right now, the main_controller is large, but not overwhelmingly large, but increasing this even further could make it too large and hard to navigate. 
-	Even though the functionality for information flow isn't yet incorporated, from the attached figures and read.me, we understand how it should be, and it makes sense. 
-	There are a lot of unnecessary comments, they are too informative. All the comments in main_elevator, it is just repeating what is already written. On the contrary the comments for the different controllers are nice and give an overview even though not implemented. 
-	Some function names are a bit confusing. Some names describe something a bit different from what the function is really doing. An example of this is OrderDistributionMessages, which sounds like it should distribute orders, or send orders to elevators, but what it does is unpacking the orders from the HRA. 
-	Some discrepancies in the folder structure. Some files contain multiple functions related to the same module, while others have one file per function within one module. For instance, in the fsm you have all functionality within the fsm file. While in the hall_Order_assigner you have one file per function. 
-	We gave this project an 8 in code quality, but there might be problems if the code base grows larger as stated above. 

Reviewer 2:
8
README-filen gir en grundig og godt strukturert oversikt over prosjektet, noe som gjør det enkelt å forstå kodens oppbygning og de ulike modulenes rolle. 
Bruken av kanaler og select for asynkron kommunikasjon er gjennomført på en ryddig og effektiv måte. Koden er godt tilpasset et distribuert system, og strukturen legger til rette for skalerbarhet. 
Variabelnavn er til tider unødvendig lange, for eksempel kunne is_elevator_obstructed vært forkortet til obstruction. Kanaler er noen steder skrevet ut som channel, mens andre steder forkortet til chan, noe som skaper inkonsistens. Enhetlig navngiving ville gjort koden mer sammenhengende og lesbar.
Funksjonsnavn har ulik formatering på tvers av moduler, der noen bruker En_Funksjon, mens andre bruker enFunksjon. I tillegg virker det unødvendig å prefikse funksjonsnavn med modulnavn når de allerede kalles via modulen, for eksempel fsm.Fsm_init(), som kunne vært fsm.Init().
Init-funksjonene er noe uoversiktlige. fsm_init() kaller kun en annen funksjon i elevator.go, og kunne kanskje vært slått sammen for å gjøre koden mer direkte. I Fsm_on_init_between_floors() settes heisen til å bevege seg oppover, men det er uklart hvordan den vet når den skal stoppe. 
Det er lite feilhåndtering i tilfeller der en heis blir utilgjengelig eller mister nettverkstilkoblingen. En mer robust failover-mekanisme ville gjort systemet mer pålitelig. Det er også uklart hvordan master- og backup-heiser velges og synkroniseres ved feil.
Mange globale variabler er definert i main_controller.go og main_elevator.go, noe som gjør debugging vanskelig og reduserer vedlikeholdbarheten. En bedre løsning ville vært å ha disse i structs, noe som også kunne redusert antallet input-parametere i flere funksjoner. Samtidig er det bra at variablene er tydelig definert og gruppert, noe som gjør det enkelt å finne dem.

Reviewer 3:
7
The code was a bit unorganized with three separate main functions, and made it hard to understand where one should look to get an overview of the systems components. 
It was not possible to see what modules the system was split into or how each module interact. 
A bit unclear names of some local variables, for example it is not clear what a healthy elevator is. 
There are used several global variables (controller_id, is_elevator_healthy in main_controller.go), which could lead to race conditions if multiple goroutines access them.
The structure of the program makes it difficult to follow the flow of information. 
The comments often explain the functions well. 
The readme file was a bit too extensive. 

Reviewer 4:
8
1. In the main.go-file the group initiates main communication channels for peer communication. It is easy to see that the process is split into the two functions main_controller() and main_elevator().
2. We can see that this code is a work in progress, and it is nice to see that you have clearly defined functions and controller states in main_controller() that clearly will be used in further iterations.
3. The README.md file is highly appreciated.
4. Some parts of the code was better documented than others, but reasonable variable, function and module namings made navigating the flow of the code easier.
5. It isn't mentioned which of Network or main.go is the current working branch, as they provide three different main loops. 
6. Remember to add some handshake functionality even with UDP. A slave node must know if the order it has sent to the network has also been recieved. Likewise, a master node must know if the "order distribution" is acknowledged.
7. Could it be practical that all slaves keep backup-information? (This is based on the attached UML). What if two elevators are disconnected at the same time and this is the master and its backup. The last (or more if there are more than three) will probably need to know of all the current orders.
8. How can an elevator know if it is the only elevator on the network, or that it has disconnected from the others? We tried to solve this by listening to our own echo on the network, but there is most likely other solutions.
9. The grade 8 is given as the code is well modularized in many places, so that further implementation of multiple elevator functionality will not be unessecarily difficult. Back-and-forth-dependancy, made it somewhat tricky to track the flow between the files but not unmanagable.


