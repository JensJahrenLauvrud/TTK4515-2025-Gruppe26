Reviewer 1:
7
- The project has a clear structure. None of the functions are too long and are usually not doing too many things at once.
- You have multiple nested Goroutines in your code (in main.go), where you run RunSingleElevator, RunMonitorPeers, RunMasterElection, etc as Goroutines, which themselves start Goroutines. This adds complexity and makes the code hard to read. An easy fix for RunMonitorPeers would be to just move the "go monitorPeers; go announceSelf" to main(), removing this function entirely
- Unnecessary Goroutines:
It is difficult to understand why announceSelf() in peer_monitor.go is started as its own Goroutine, since it just starts the peers.Transmitters(). The for loop at the end of the function is not necessary to keep the peers.Transmitter() running, and does nothing.
Also, in RunOrderAssignment, each time you receive a hall call on hallCallChan as master and call SendHallAssignment(), you start a new BroadcastHallAssignment() as a Goroutine, which in turn starts a new bcast.Transmitter Goroutine. This Goroutine never terminates and the channel for communication to it just goes out of scope. This means that every time you call SendHallAssignment you invoke a Transmitter Goroutine to the same port that never terminates or is used again. 
- When you in main.go start the Goroutine RunMonitorPeers, this function just starts two other functions as Goroutines. This makes it difficult to get an overview of the active processes in your program, since this nesting of Goroutines makes the connection between processes (over channels) hard to follow. 
- In both RunOrderAssignment and RunMasterElection, you receive on (the same global) ElevatorStateChan. This makes it random/arbitrary which of the processes actually gets the message. 
- The main function provides a good overview over the system's modules, but is abstracted to the point where the flow of execution is hard to follow. The channel names could be improved to better reflect the direction of data flow (input or output, e.g. incomingHallRequests and assignedHallOrders instead of hallCallChan and assignedHallCallChan, or maybe add Tx and Rx or something to make it more obvious). You should also keep channel naming consistent (in main.go most of the channels end with "Chan" except peerUpdates, just nitpicking).
Overall, although the attached diagram indicated simple communication between few processes, the actual code made getting a good picture of the flow of data and active processes very hard.

Reviewer 2:
9
Very well structured and organized project.
Comments and documentation done in a way that makes the project much easier to understand.
Maybe add some error handling or simply a default case in some of the switch cases to make the code more robudt.  
Why snake_case in module names and camelCase in function names? Choose one.
Function names are very descriptive and easy to understand.
Concurrency is very well handled and structured.

Reviewer 3:
9
The comments were good, and helped the code readability.
Architecture, line 8 in README: does the master-elevator not execute hall-orders? From the code it is clear that this elevator also handles orders. But there is a conflict in your documentation.
Main is short and nicely structured. Dependencies are clear. Although, what is meant by 'initializing connection to a simulator'? Also, is it necessary/practical to use environment variables? Why not use args?
Traceability-wise, your code is easy to follow using the overview figure. 
Master election: why have you called a map with values of type ElevatorStatus for elevatorStates?
Network: Could make the network module pure, only providing general network functionality.
Order assignment: Why not use Abs from the math package, since you're already using math (config.go)?
In RunOrderAssignment you choose to run a go func(). Why? The RunOrderAssignment is already being run as a goroutine from main? This seems redundant.
In general: types are neatly defined and modules are well modularized. Looks like the project can easily be maintained.

Reviewer 4:
7
- The code is well structured and has clear areas of responsibility for each module.
- Comments are clear and concise. And describe the purpose of each function and model.
- Main is clean, but maybe consider a init function?
- The single elevator seems effective and well implemented.
- order_assignment ensures reassigning of orders that are not done. 
- Master election is well implemented.
- Master election doesn't seem to be used more than once in the beginning. So it cannot handle loss of Master yet?

