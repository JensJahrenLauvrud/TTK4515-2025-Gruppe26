Reviewer 1:
7
- The master thread has multiple responsibilities: handling network communication, state transitions, and elevator control logic in a single loop. It might be okay in the beginning, but I think it is better to follow the Single Responsibility Principle later in the project, modularizing all the code better. When the codebase will increase it will be harder to modify or extend this code. 
- The busy-wait loop in the slave code might be reviewed, it can be inefficient.
- Magic numbers, like 3 second timer, port numbers or byte offsets are declared without particular structure, I would suggest using some config file where you can set it. 
- Packet manipulation is done using memset on arbitrary packet regions. it might lead to bugs. Implementing a packet builder/parser would be better
- Efficient use of multi-threading with pthreads, good grasp of concurrent programming. 
- Overall, the code is pretty balanced and meets core elevator functionalities 

Reviewer 2:
6
-	It is difficult to get an overview on the principles of the system because there are no clearly
	defined modules with its own responsibilities. Everything, except from hardware interface, is
	happening in the main-loop or in 'thread_routine'. This makes it hard to keep track of what is
	happening.
-	Functions, please use them. Having all the functionality happen in the driver and in
	main/thread_routine makes all of the functionality/responsibility complect (not a typo).
	From the smaller things such as turning some of the messier if-statements into an
	`if (function())` to make it more clear what you are checking for, to the bigger and more
	important things such as turning order assignments, order backup, the state machine, etc...
	into functions/modules. Functions aren't there to just remove repetition of code, it's also
	a valuable tool to categorise functionality and make the code more readable. Having everything
	in main/thread_routine makes the code inflexible and hard to read. Fewer functions does not
	equal less complexity, often the opposite.
	https://www.infoq.com/presentations/Simple-Made-Easy/
-	It is hard to understand how different problems are handled. For instance, where do the order
	assignment happen? Who is responsible for it? Who keeps tracks of whether an order gets
	completed or not? Etc...
-	How you are getting information from the driver could also be made more readable. The procedure
	of sending a command and then extracting the result each time you need some information could be
	made more clear by hiding some of the complexity in the driver module, or having an own module
	for handling the interface with the driver. It's also worth asking why you're not using the
	driver provided by the course, as it uses a more legible and conventional interface. It seems
	like you've given yourself extra work without any added benefits, unless the official driver
	is broken?
-	In the thread routine, there are some comments that are redundant, because it's quite clear
	what is happening. Where it is not so obvious what is happening, there are mostly no comments.
	Though dividing the program into modules with a clear purpose would be preferred over just
	adding comments explaining what each part does.
-	Overall it is quite hard to follow what is happening in the code. To even see if there is any
	handling of the master crashing, or where this possibly should be implemented is not easy to
	see.

