Reviewer 1:
7
- The main entry points for the projects, especially "elevator.rs" and "database.rs", are too long. This is because all the threads which are started in these entry points are also defined there. It would be benefical to move them out to their own files, or at least declare them as seperate functions outside of the main function. That way one will be able to get an overview of which threads are started in main without having to scroll hundreds of lines.
- Your project has a lot of comments whic is great! However, many of them seem rather reduntant or little helpfull. For example the comment "We wait in stop state until something new happens" for the line "if something_new == true {" or the comment "Function to execute the algorithm" for the function "run_cost_algorithm". Some seem also indicative of bad code quality. For example the "START" and "STOP" comments in your main functions seem like a plaster for the length of the function.
- The naming of some modules/variables/functions could be better. For example it was unclear for us what the modules "manager.rs" was managing. A better name could for example be "request_manager" or maybe even "request_assigner". In the same vein you have a lot of "utils" files. Another example is all the "handle_*" functions in "elevator_logic/state_machine.rs". What are they handling? Are they even handling anything? All that they do is simply returning the next state the system should be in.
- A the topmost level, we think the way that the system is divided into "elevator", "database" and "manager" is good and that they have logical areas of responsebilities. (Even if they could use some better names.) However, when you go a bit deeper the sub modules become a bit disorganized. For example one would think that "elevator_logic" folder contains the logic for controlling the elevator, especially with a file like "state_machine", but this is not the case and the logic lives in fact in the entrypoint "elevator.rs". Maybe this is work in progress? Another example is "distributed_systems". First of all, the name "distributed_systems" is very vague. Especially as the entire project revoles around building a distributed system, so one could argue that the entire project could be placed inside this submodule. Looking deeper we only find a file called "utils.rs" which further adds to the vagueness. Inside it there are functions for both handling timeouts, getting router ip, parsing messages and a struct for elevator backup and elevator requests. This structure should probably be reworked entierely. Maybe into some kind of network module with a file for functions for parising to and from json, another file for networking function like getting ip and status. The structs should probably be moved to another place as elevator backup and elevator requests seem like something more than some networkning utilities.
- There is a lot of repetition in your code which makes it longer and in turn harder to follow. For example, in a lot of places where you handle hall requests the same code is run twice, once for hall requests up and another for down. Only wheter the code modifies up or down is different. Maybe you could factor out the shared logic into sperate functions? If this is difficult/not possible that might be a clue that you should use another datastructure for your requests. Another example is the "TOPIC" constatns. They are currently specified at the top of each file and have to mach exactly the same as in the other files. A simple shared configuration file would make this simpler and guarantee correctness.
- This project heavily uses shared variables shared between many different threads. This makes it difficult to follow what is changed and where it is changed. For exampe "hall_up_queue" is used in five different threads: "Backup data initialization", "Listen to manager", "Button order light", "Backup data", and "Sate machine". It is not immediatly clear which of these set and/or read this variable. Furthermore, the interaction between the threads are also hidden. It is not clear which way the information flows. Here a channel based approach might have several advantages.
- Some places the nesting is pretty deep which makes the code harder to follow. This applies especially the sate machine for the elevator. Simple techniques like splitting functionality into functions and inverting if statmenets (https://www.youtube.com/watch?v=CFRhGnuXG-4) can help reduce this.
- If you find yourself writing tedious patterns I would recommend Googling (or asking ChatGPT) if Rust has a nicer way of writing it. Most likely someone has though about it. For your file "elevator_logic/state_machine.rs", take a look at ".some_then()". For the tedious state_backup, _prev_state pattern in elevator.rs, why not simply derive Copy?
- The state machine desicion pattern with "found_solution" is not easy to follow. Having to check every single variable to decide what the next condition should be seems convoluted. Here a channel based approached could be benefical as you could invert this pattern. Instead of checking all the variables based on what sate you are in, you could check what state you are in based on what variable changed and then act accordingly.

Reviewer 2:
9
There is consistency in the naming convention across the project. All variable use snake_case and all data types use PascalCase.
The code is split into different descriptive modules. This ensures the code is readable and maintainable. 
The code contains a lot of comments which helps with understanding the functionality of the code. 
In elevator.rs, a lot of HashSets are created and cloned. Hashsets contain a large overhead and can be memory intensive. Memory is very limited on embedded systems.
Using libraries such as Zenoh and Tokio is great for keeping the code readable and maintainable, however, these libraries can occupy a large amount of flash memory and they may contain functionalities that are not useful for the project. 
The design contains two databases and 3 elevators. Since the system is constrained to three machines/nodes, the databases will need to run on the same machine as the elevators. The project requirements state that two machines/nodes can malfunction. This means that both databases could fail. 
The code looks easy to debug considering the fact that a lot of print statements are included.

Reviewer 3:
9
- Good use of asynchronous programming patterns with `tokio`, which supports concurrent handling of tasks clearly and efficiently.
- Effective use of `Arc`, `RwLock`, and `Mutex` demonstrates thoughtful consideration of thread safety and concurrent data management, though extensive use of locks might lead to performance bottlenecks or potential deadlocks in more complex scenarios.
- Consistent application of Rust features such as `Lazy` initialization (`once_cell`) and environment variable handling enhances flexibility, but the extensive reliance on environment variables could complicate debugging or setup for new users.
- Code readability is generally good due to meaningful naming conventions; however, certain function names or module paths (`data`, `utils`) remain vague and could be improved for quicker understanding.
- Comments are present but overly informal at times, mixing humorous or casual language (e.g., "Killing myself... ReeeEEEEeeee!") with technical explanations. More professional and concise commenting could enhance clarity(JK).
- The handling of network disconnection (`network_status`) is clear, yet abruptly terminating the application (`std::process::exit(1)`) might not be ideal for robustness or recovery in real-world scenarios.
- Configuration handling via environment variables (`ELEVATOR_NETWORK_ID`, `NUMBER_FLOORS`) is functional but lacks clear error-handling or informative fallback procedures for incorrect inputs or missing configurations, potentially causing runtime errors.

Reviewer 4:
7
General: The system’s overall design is well thought through, but the implementation could benefit from simplification.
Understandability: The code includes intuitive variable names making it easy to understand the low-level functionality. 
Modularizations: The modules, elevator.rs, manager.rs, and database.rs, combines multiple responsibilities, such as network initialization, hardware I/O, state machine management, and backup handling. This reduces clarity on each module’s primary purpose and the ability to easily get an overview of the entire process. You should consider refactoring these into smaller, task-specific sub-modules. For example, implementing the elevator state machine as a dedicated module and spawn this in its own thread in elevator.rs. This approach encapsulates the state machine’s functionality, simplifies maintenance, and makes the overall structure of elevator.rs clearer and more modular. 
Traceability and Sates: While using Arc ensures thread safety, repeatedly cloning and passing states into multiple threads makes it difficult to pinpoint the origin of state changes during debugging. Additionally, the broad scope of several state variables makes it difficult to determine ownership of each piece of state. A more structured approach, leveraging channels for inter-thread communication, could reduce both shared states overhead and large scope.
Comments: The extensive comments indicate that the code’s structure is too convoluted. Simplifying the modularizations so that the code becomes self-explanatory will help reduce the need for verbose commentary, enhancing readability and maintainability.
Functions: You could increase the use of generic functions with clearly defined inputs and outputs to enhance readability and reduce repetitive code. 
Error handling: Instead of terminating the entire process immediately upon encountering an error, a more robust error recovery strategy should be implemented. For example, a single message transmission or receiving error should not be enough to force the program to exit. Instead, a retry mechanism could be used, allowing the system to recover from transient issues, improving resilience and minimizing downtime.

Reviewer 5:
8
bullet point 1: I struggle to find where the main program starts when running the entire system (not the examples), which makes it difficult to get an overview of how the system is connected at a top level. I would recommend trying to start everything from one program if possible, instead of running three separate bash programs.
bullet point 2: Even after reading more of the code, I still struggle to understand the main structure of the problem. It appears to be peer-to-peer but has a leader, a manager, and a backup. I would recommend explaining how the modules interact at the start of the program. (Note: I am ignoring the report, as this should not be part of the evaluation.)
bullet point 3: You have comments before blocks of code that explain the main tasks in many places, but it could be useful to add comments for smaller parts of the code as well. For example, in database.rs (lines 169–198), where the for loop could be collapsed when reviewing the code, it would be helpful to have a brief comment before it.
bullet point 4: In some places, you could clarify and shorten the comments—for instance, in lines 205–216 of database.rs. I would recommend letting the code speak for itself or commenting on specific lines rather than explaining the code line by line before it even starts. A few words on what is to be achieved would suffice.
bullet point 5: I would recommend separating the manager and leader roles more clearly to improve readability, as they can be confused in the current implementation.
bullet point 6: The functions and their naming are good and understandable.

