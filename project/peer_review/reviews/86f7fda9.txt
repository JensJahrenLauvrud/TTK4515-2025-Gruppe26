Reviewer 1:
6
- The main function gives a ok overview over what channels and functions that are initialized. But the main function should only initialize channels and go routines, and not handle events it self, it makes the code messy.
- There is little use of global variables which is good, some values are hardcoded in the network module.
- It's hard to find out if the system is peer-to-peer or master-slave, due to the there being very little communication-code implemented.
- Some of the comments are reduntant due to the commented code being obvious to understand.
- The system is supposed to be p2p but in the existing code there is missing alot of things to make it work with multiple elevators, such as a orderassigner and a way of achieving consistency between all the elevators on the network
- The for loop in the main function seems redundant, as it only exists as a way of passing a value from the "drv" channels from the elevio module to the elevatorstate module
- The naming convention seems good and consistent across the project.

Reviewer 2:
6
•Structure: the system is divided into elevator goroutine and communication goroutine. That seems reasonable, given the commucation part also handles order distribution across the elevators. The Poll goroutines in main.go should probably be moved into RunElevator goroutine to encapsulate the logic.
•State synchronization: seems like a good idea to communicate between elevator and communication goroutines using a set of channels.
•Code quality: handler functions in RunElevator seem to be unnecessary, the code is already modularized because it is inside a case statement. See the code quality lecture from Anders on BB to see what we mean :).
•Final thoughts: The group has not showed any design choices of what mechanisms are used to tackle hall order distribution, state synchronization or fault tolerance. They did mention the finished system will be P2P, but it probably needs more code for the reader to understand what solutions this group made. 

Reviewer 3:
8
Overall pretty good! Function and variable names make a decent amount of sense, and most functions, while a bit large for my liking, look reasonable.
Main function isn’t a pure function. Main usually only handles initialization of modules and their connections, and should not do anything else. Here main starts by initializing and then proceeds to go into a for loop where it does some elevator & order control. I recommend making it so main is purer so that you don’t have 1 module that randomly receives messages from main, which is a place you’re not expecting information to flow from.
Main isn’t completely clear. It starts by fetching network items from the flags. Then proceeds to initialize the elevator, before finally initializing the network communication. Some of this feels like it could be helper functions to main (i.e. Init_Elevator which handles elevio and elevator inits.) I recommend trying to do this as it makes it more obvious what main does and in what order.
The communication module has a template function that handles elevator states. - This feels like it should be in the elevator module and instead be a go channel from the communication module to the elevator module. Alternatively it could be its own module. I recommend separating the communication from states almost completely so that you’re not handling edge cases about states in the same code where you’re receiving a text message on the network.
The communication module doesn’t provide any clear way of using it to send or receive messages. (There are no template Send, Broadcast or Receive functions/channels - even if they’re not implemented yet). I recommend having the template in place so that you have an idea of what you’re trying to implement and why each function you’re creating is meant for.
Some functions can be split into more functions. For example the function handleNewOrder in the elevator module has some cases in its select-case statement that can be separated out of the case and just be handed its information. I recommend doing this as it makes it more obvious whether or not handleNewOrders (and other functions) are correct when writing them. Additionally it removes ambiguity on what the block of code is doing in each case.
Some function names can be even more explicit in their purpose. The functions ordersBelow and ordersAbove do not immediately scream “I check if there’s an order below/above the elevator”. Actually, it makes more sense if they returned a list of the orders above or below the elevator. I recommend a more explicit name such as “isAnyOrdersBelow()” or similar. That way it is more immediately obvious what the function does and why it is correct. To check if a function is doing what its name says, ask someone you know what they think a function with name X does. If they answer what it does, then the function name is good, otherwise it could probably be made better.

Reviewer 4:
9
-Good overview in main function. The for loop could have been in a separate file to increase readability.
-Hardcoding the CabCallStruct and hallCallStruct makes it difficult to change number of floors.
-All modules are clear and seems to have one defined group of tasks.
-All statechanges happen in the elevatorStateMachine, it is easy to keep track of where changes in variables happen.
-All the functions have a separate task. No overlap or double tasks in one function.
-A lot of the comments are repetition of code. The variable/function names speak for themselves.

